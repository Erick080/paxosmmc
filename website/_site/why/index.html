<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Paxos Made Moderately Complex | Explains the Paxos Consensus Protocol in an easy to understand way. Provides a working implementation in Python.</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Paxos Made Moderately Complex" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Explains the Paxos Consensus Protocol in an easy to understand way. Provides a working implementation in Python." />
<meta property="og:description" content="Explains the Paxos Consensus Protocol in an easy to understand way. Provides a working implementation in Python." />
<link rel="canonical" href="http://localhost:4000/why/" />
<meta property="og:url" content="http://localhost:4000/why/" />
<meta property="og:site_name" content="Paxos Made Moderately Complex" />
<script type="application/ld+json">
{"description":"Explains the Paxos Consensus Protocol in an easy to understand way. Provides a working implementation in Python.","@type":"WebPage","headline":"Paxos Made Moderately Complex","url":"http://localhost:4000/why/","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Paxos Made Moderately Complex" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Paxos Made Moderately Complex</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/how/">Paxos</a><a class="page-link" href="/paper/">Paper</a><a class="page-link" href="/code/">Code</a><a class="page-link" href="/glossary/">Glossary</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title"></h1>
  </header>

  <div class="post-content">
    <h1 id="whyis-paxos-used-in-distributed-systems">Why is Paxos used in distributed systems?</h1>

<p><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-paxos.pdf"><strong>Paxos</strong></a> is a protocol for state machine replication in an asynchronous environment that admits crash failures.</p>

<p>A replicated state machine works by having multiple state machines, also called replicas, working in parallel, maintaining the same state. When the replicas receive requests from a client they update their state by executing the command in the request and reply to the client. This way, the state is automatically replicated by the replicas and in the event of a failure the state does not get lost, making the replicated state machine reliable.</p>

<p>It is easy for replicas to execute client commands in the same order and remain in sync if there is only one client or if multiple clients send their requests strictly sequentially as shown below:</p>

<p><img src="../static/rsm.gif" width="300" height="300" /></p>

<p>In this example replicas receive requests from clients in the same order, execute the commands in the same order and respond to the clients, in effect staying in sync. For simplicity, it is assumed that a client can ignore duplicated responses.</p>

<p>But if multiple clients send requests to replicas in parallel, then different replicas might receive these requests in different orders and execute the commands in different orders, causing their local states to diverge from one another over time.</p>

<p>To prevent replicas from diverging in the presence of multiple clients sending requests in parallel, the order in which the client commands will be executed by replicas should be decided. We show this case below:</p>

<p><img src="../static/consensus.gif" width="420" height="300" /></p>

<p>To decide the order in which the client commands will be executed the replicas can be thought of as having a sequence of slots that need to be filled with commands that make up the inputs to the state machine they maintain. In the example this sequence is shown as a table. Each slot is indexed by a slot number, starting from 1. Replicas receive requests from clients and assign them to specific slots, creating a sequence of commands. In the face of concurrently operating clients, different replicas may end up proposing different commands for the same slot. To avoid inconsistency, a consensus protocol chooses a single command from the proposals for every slot. In Paxos the subprotocol that implements consensus is called the <strong>multi-decree Synod</strong> protocol, or just <strong>Synod</strong> protocol for short. A replica awaits the decision before actually updating its sequence of commands in the table, executing the next command and computing a response to send back to the client that issued the request.</p>

<p>Essentially, the replicated state machine uses Paxos as an ordering entity which uses consensus to agree on which client command gets assigned to which slot. One has to make sure that the ordering entity itself is also reliable, that it can tolerate failures (at most <em>f</em>) just like the replicated state machine. To achieve reliability, Paxos is run by multiple specialized processes in a distributed fashion. This is not trivial because up to <em>f</em> processes running Paxos might fail at any time and, because there is no bound on timing for delivering and processing messages, it is impossible for other processes to know for certain that the process has failed.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Paxos Made Moderately Complex</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Paxos Made Moderately Complex</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/denizalti"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">denizalti</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Explains the Paxos Consensus Protocol in an easy to understand way. Provides a working implementation in Python.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
