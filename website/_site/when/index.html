<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Paxos Made Moderately Complex | Explains the Paxos Consensus Protocol in an easy to understand way. Provides a working implementation in Python.</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Paxos Made Moderately Complex" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Explains the Paxos Consensus Protocol in an easy to understand way. Provides a working implementation in Python." />
<meta property="og:description" content="Explains the Paxos Consensus Protocol in an easy to understand way. Provides a working implementation in Python." />
<link rel="canonical" href="http://localhost:4000/when/" />
<meta property="og:url" content="http://localhost:4000/when/" />
<meta property="og:site_name" content="Paxos Made Moderately Complex" />
<script type="application/ld+json">
{"description":"Explains the Paxos Consensus Protocol in an easy to understand way. Provides a working implementation in Python.","@type":"WebPage","headline":"Paxos Made Moderately Complex","url":"http://localhost:4000/when/","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Paxos Made Moderately Complex" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Paxos Made Moderately Complex</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/how/">Paxos</a><a class="page-link" href="/paper/">Paper</a><a class="page-link" href="/code/">Code</a><a class="page-link" href="/glossary/">Glossary</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title"></h1>
  </header>

  <div class="post-content">
    <h1 id="when-does-paxos-work-aka-what-about-the-impossibility-of-consensus-result">When does Paxos work? a.k.a. what about the impossibility of consensus result?</h1>

<p>It would clearly be desirable that, if a client broadcasts a new command to all replicas, that it eventually receives at least one response. This is an example of a liveness property. It requires that if one or more commands have been proposed for a particular slot, that some command is eventually decided for that slot. Unfortunately, the Synod protocol as described does not guarantee this, even in the absence of any failure whatsoever. In fact, failures tend to be good for liveness. If all leaders but one fail, Paxos is guaranteed to terminate.</p>

<p><img src="../static/pingpong.png" /></p>

<p>Consider the following scenario shown above, with two leaders with identifiers Œª and Œª‚Ä≤ such that Œª&lt;Œª‚Ä≤. Both start at the same time, respectively proposing commands c and c‚Ä≤ for slot number 1. Suppose there are three acceptors, Œ±1, Œ±2, and Œ±3. In ballot ‚ü®0,Œª‚ü©, leader Œª is successful in getting Œ±1 and Œ±2 to adopt the ballot, and Œ±1 to accept pvalue ‚ü®‚ü®0,Œª‚ü©,1,c‚ü©.</p>

<p>Now leader Œª‚Ä≤ gets Œ±2 and Œ±3 to adopt ballot ‚ü®0,Œª‚Ä≤‚ü©, which has a higher ballot number than ballot ‚ü®0,Œª‚ü© because Œª&lt;Œª‚Ä≤. Note that neither Œ±2 or Œ±3 accepted any pvalues, so leader Œª‚Ä≤ is free to select any proposal. Leader Œª‚Ä≤ then gets Œ±3 to accept ‚ü®‚ü®0,Œª‚Ä≤‚ü©,1,c‚Ä≤‚ü©.</p>

<p>At this point, acceptors Œ±2 and Œ±3 are unable to accept ‚ü®‚ü®0,Œª‚ü©,1,c‚ü© and thus leader Œª is unable to get a majority of acceptors to accept ‚ü®‚ü®0,Œª‚ü©,1,c‚ü©. Trying again with a higher ballot, leader Œª gets Œ±1 and Œ±2 to adopt ‚ü®1,Œª‚ü©. The maximum pvalue accepted by Œ±1 and Œ±2 is ‚ü®‚ü®0,Œª‚ü©,1,c‚ü©, and thus Œª must propose c. Suppose Œª gets Œ±1 to accept ‚ü®‚ü®1,Œª‚ü©,1,c‚ü©. Because acceptors Œ±1 and Œ±2 adopted ‚ü®1,Œª‚ü©, they are unable to accept ‚ü®‚ü®0,Œª‚Ä≤‚ü©,1,c‚Ä≤‚ü©. Trying to make progress, leader Œª‚Ä≤ gets Œ±2 and Œ±3 to adopt ‚ü®1,Œª‚Ä≤‚ü©, and gets Œ±3 to accept ‚ü®‚ü®1,Œª‚Ä≤‚ü©,1,c‚Ä≤‚ü©.</p>

<p>This ping-pong scenario can be continued indefinitely, with no ballot ever succeeding in choosing a pvalue. This is true even if c=c‚Ä≤, that is, the leaders propose the same command. The well-known ‚Äò‚ÄòFLP impossibility result‚Äô‚Äô demonstrates that in an asynchronous environment that admits crash failures, no consensus protocol can guarantee termination, and the Synod protocol is no exception. The argument does not apply directly if transitions have non-deterministic actions‚Äîfor example changing state in a randomized manner. However, it can be demonstrated that such protocols cannot guarantee a decision either.</p>

<p>If we could somehow guarantee that some leader would be able to work long enough to get a majority of acceptors to adopt a high ballot and also accept a pvalue, then Paxos would be guaranteed to choose a proposed command. A possible approach could be as follows: when a leader Œª discovers, through a ùöôùöõùöéùöéùöñùöôùöùùöéùöç message, that there is a higher ballot with leader Œª‚Ä≤ active, rather than starting a new scout with an even higher ballot number, Œª starts monitoring Œª‚Ä≤ by pinging it on a regular basis. As long as Œª‚Ä≤ responds timely to pings, Œª waits patiently. Only if Œª‚Ä≤ stops responding will Œª select a higher ballot number and start a scout.</p>

<p>This concept is called failure detection, and theoreticians have been interested in the weakest properties failure detection should have in order to support a consensus algorithm that is guaranteed to terminate. In a purely asynchronous environment, it is impossible to determine through pinging or any other method whether a particular leader has crashed or is simply slow. However, under fairly weak assumptions about timing, we can design a version of Paxos that is guaranteed to choose a proposal. In particular, we will assume that both the following are bounded:</p>

<p>the clock drift of a process, that is, the rate of its clock is within some factor of the rate of real-time;
the time between when a non-faulty process initiates sending a message, and the message having been received and handled by a non-faulty destination process.
We do not need to assume that we know what those bounds are‚Äîonly that such bounds exist. From a practical point of view, this seems entirely reasonable. Modern clocks progress certainly within a factor of 2 of real-time. A message between two non-faulty processes is likely delivered and processed within, say, a year. Even if the network was partitioned at the time the sender started sending the message, by the time a year has expired the message is highly likely to have been delivered and processed.</p>

<p>These assumptions can be exploited as follows: we use a scheme similar to the one described above, based on pinging and timeouts, but the value of the timeout interval depends on the ballot number: the higher the competing ballot number, the longer a leader waits before trying to preempt it with a higher ballot number. Eventually the timeout at each of the leaders becomes so high that some correct leader will always be able to get its proposals chosen.</p>

<p>For good performance, one would like the timeout period to be long enough so that a leader can be successful, but short enough so that the ballots of a faulty leader are preempted quickly. This can be achieved with a TCP-like AIMD (Additive Increase, Multiplicative Decrease) approach for choosing timeouts. The leader associates an initial timeout with each ballot. If a ballot gets preempted, the next ballot uses a timeout that is multiplied by some small factor larger than one. With each chosen proposal, this initial timeout is decreased linearly. Eventually the timeout will become too short, and the ballot will be replaced with another even if its leader is non-faulty.</p>

<p>Liveness can be further improved by keeping state on disk. The Paxos protocol can tolerate a minority of its acceptors failing, and all but one of its replicas and leaders failing. If more than that fail, consistency is still guaranteed, but liveness will be violated. A process that suffers from a power failure but can recover from disk is not theoretically considered crashed‚Äîit is simply slow for a while. Only a process that suffers a permanent disk failure would be considered crashed.</p>

<p>For completeness, we note that for liveness we also assumed reliable communication. This assumption can be weakened by using a fair links assumption: if a correct process repeatedly sends a message to another correct process, at least one copy is eventually delivered. Reliable transmission of a message can then be implemented by periodic retransmission until an ack is received. In order to prevent overload on the network, the time intervals between retransmissions can grow until the load imposed on the network is negligible. The fair links assumption can be weakened further, but such a discussion is outside the scope of this paper.</p>

<p>As an example of how liveness is achieved, a correct client retransmits its request to replicas until it has received a response. Because there are at least  f+1 replicas, at least one of those replicas will not fail and will assign a slot to the request and send a proposal to the  f+1 or more leaders. Thus at least one correct leader will try to get a command decided for that slot. Should a competing command get decided, the replica will reassign the request to a new slot and retry. While this may lead to starvation, in the absence of new requests, any outstanding request will eventually get decided in at least one slot.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Paxos Made Moderately Complex</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Paxos Made Moderately Complex</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/denizalti"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">denizalti</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Explains the Paxos Consensus Protocol in an easy to understand way. Provides a working implementation in Python.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
